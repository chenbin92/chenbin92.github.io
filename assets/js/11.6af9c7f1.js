(window.webpackJsonp=window.webpackJsonp||[]).push([[11],{157:function(t,s,a){"use strict";a.r(s);var e=a(0),r=Object(e.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"常见问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#常见问题"}},[t._v("#")]),t._v(" 常见问题")]),t._v(" "),a("h2",{attrs:{id:"与-next-js-有什么区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#与-next-js-有什么区别"}},[t._v("#")]),t._v(" 与 Next.js 有什么区别?")]),t._v(" "),a("p",[t._v("Next.js 定位与 React 服务端框架，而 ice.js 则定位于 React 通用型框架，支持 SPA、SSR、MPA、Serverless、微前端等流行的应用类型。")]),t._v(" "),a("h2",{attrs:{id:"与-nuxt-js-有什么区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#与-nuxt-js-有什么区别"}},[t._v("#")]),t._v(" 与 Nuxt.js 有什么区别?")]),t._v(" "),a("p",[t._v("ice.js 在框架设计上一定程度上借鉴了 Nuxt.js 的思想，它好比是 Nuxt.js 之于 Vue， ice.js 之于 React。")]),t._v(" "),a("h2",{attrs:{id:"与-umijs-有什么区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#与-umijs-有什么区别"}},[t._v("#")]),t._v(" 与 UmiJS 有什么区别?")]),t._v(" "),a("p",[t._v("UmiJS 的核心也就是 roadhog 和路由约定式的能力，以及配合其周边生态的 dva、antd、antd-pro 的解决方案形成完整的体系。而 ice.js 除了 ice-scripts 的工程插件能力和约定式路由之外，更多的是向 nuxt.js 学习，提供了基于框架级别的全局 API、数据请求、状态管理、日志等核心功能，同时遵循 「约定优先于配置的原则」严格区分工程插件和应用插件去扩展定制框架的能力。")]),t._v(" "),a("h2",{attrs:{id:"与-build-script-有什么区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#与-build-script-有什么区别"}},[t._v("#")]),t._v(" 与 build-script 有什么区别?")]),t._v(" "),a("p",[t._v("build-scripts 是一个基于 Webpack 的工程工具，其核心是基于 webpack 的封装和插件内核能力。而 Nuxt.js 更多的解决的是编码开发时的能力，诸如框架层面的数据流方案、数据请求方案、路由方案等等。")]),t._v(" "),a("h2",{attrs:{id:"与脚手架有什么区别？"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#与脚手架有什么区别？"}},[t._v("#")]),t._v(" 与脚手架有什么区别？")]),t._v(" "),a("p",[t._v("诸如社区前几年有太多的 react 脚手架了，这些脚手架多是一些方案的组合，基于脚手架创建项目后，90% 的开发者会基于脚手架定制符合业务的脚手架，与原有脚手架失去了粘性或者说几乎不会再用。究其原因如下：1）脚手架的组合的方案不是开发者需要的，可以随时被替换掉。2）当脚手架被初始化项目之后，两者是分离的无法升级。 3）脚手架的能力是有限的无法持续扩展出新的能力。")])])}),[],!1,null,null,null);s.default=r.exports}}]);